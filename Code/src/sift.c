#include "sift.h"
#include "img_io.h"
#include "Tests.h"

#undef DUMP_OCTAVE
#undef DUMP_SCALESPACE
#undef DUMP_DOG


// scale space
float scaleSpace_g[MAX_O*MAX_S*MAX_OCTAVE_SIZE];
float scaleSpaceCP_g[MAX_O*MAX_S*MAX_OCTAVE_SIZE];

// difference of gaussians
float dog_g[MAX_O*(MAX_S - 1)*MAX_OCTAVE_SIZE];


void Sift(unsigned char* input, int xsize, int ysize, unsigned char* r, unsigned char* g, unsigned char* b)
{

	// Octaves generated by down sampling
	// Careful, this memory allocation is far from optimal.
	// All octaves are given the same size as the original image
	// octavesW_g[i] * octavesH_g[i] is the actual memory necessary for octave i
	unsigned char octaves_g[MAX_O*MAX_OCTAVE_SIZE];


	// width of each octave
	int octavesW_g[MAX_O];
	// height of each octave
	int octavesH_g[MAX_O];

	float sigmas[MAX_O*MAX_S];

	// extreme points
	pointList keyPointList_g;
	pointList keyPointListCP_g;


	// Setting the original number of detected points to 0
	keyPointList_g.size = 0;

	InitSift(xsize, ysize, octavesW_g, octavesH_g,sigmas);

	buildOB(input, octaves_g, octavesW_g, octavesH_g);

	buildSS(octaves_g, scaleSpace_g,scaleSpaceCP_g,octavesW_g, octavesH_g, sigmas);

	DoG(dog_g, scaleSpace_g, octavesW_g, octavesH_g);

	extreme(&keyPointList_g, dog_g, octavesW_g, octavesH_g);

	orientation(&keyPointList_g, &keyPointListCP_g, scaleSpaceCP_g, sigmas, octavesW_g);

	render(input, octavesW_g, octavesH_g, &keyPointListCP_g, sigmas, r, g, b);

}




void InitSift(int xsize, int ysize, int * octavesW_g, int * octavesH_g, float * sigmas)
{
	int i,j;
	// computing the width of octaves at each level
	octavesW_g[0] = xsize;
	for (i = 1; i < NUMBER_OF_OCTAVES; i++){
		octavesW_g[i] = octavesW_g[i - 1] / 2;
	}
	// computing the height of octaves at each level
	octavesH_g[0] = ysize;
	for (i = 1; i < NUMBER_OF_OCTAVES; i++){
		octavesH_g[i] = octavesH_g[i - 1] / 2;
	}
	float sigma0 = 1.6f;


	// gaussian sigmas at each scale
	for (i = 0; i < NUMBER_OF_OCTAVES; i++){
		for (j = 0; j < NUMBER_OF_SCALES; j++){
			sigmas[i*MAX_S + j] = sigma0 * pow(sqrt(2.0f), (float)j / (float)(NUMBER_OF_SCALES - 3));
		}
	}
}